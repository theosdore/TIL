# 2일차

다중 선택: 싸피

## 리스트

여러개의 값을 순서대로 저장하는, 변경 가능한(mutable) 시퀀스 자료형

## 튜플

- 소괄호 없이 만들 수 있음
- 단일 요소 튜플은 반드신 후행 쉼표(Trailing comma)가 필요

## 딕셔너리

key 값을 해시값을 통해 만든다. 하지만 가변 데이터를 사용하면 해시값이 바뀌어야 함으로 이를 방지하고자 key값을 불변데이터만 지정.

```python
dic = {
"테스트" : "test"
}
print(dic.get("테스트")) #test
print(dic.get("없는키")) #None
```

## 세트

딕셔너리 세트 둘다 대괄호 { } 사용

따라서 혼용하지 않기 위해

빈세트 생성자  → set()

```python
a = {1,2,3}
b = {4,5,6}
c = {3,4}
d = {1}

print(f'''
합집합 : {a | b}
교집합 : {b & c}
대칭 합집합 : {a ^ c}
포함관계 : {d < a}
''')

> 
합집합 : {1, 2, 3, 4, 5, 6}
교집합 : {4}
대칭 합집합 : {1, 2, 4}
포함관계 : True

```

## is와 “==”

is는 메모리 주소의 비교

“ == ” 값 자체의 동일 여부

## 복사

```python
a = [1, 2, 3]
b = a  # 참조 복사 (메모리 복사)
        # 같은 객체를 가리킨다.
b[0] = 10
print(f'a = {a}')
print(f'b = {b}')
print(a is b)
print(id(a))
print(id(b))

a = [[1, 2], [3, 4]]

# 깊은 복사
# - 메모리가 완전히 다른 곳에
#  새로운 객체를 저장하겠다.
import copy
b = copy.deepcopy(a)
b[0][0] = 10
print(a)
print(b)
print(id(a))
print(id(b))

# 얕은 복사
# - 표지만 복사한 개념 (속 페이지는 공유)
# - 껍데기는 따로 쓰고, 속은 함께 쓰자
c = [1, [2, 3]]
d = c.copy()
print(id(c))
print(id(d))
d[0] = 10
print(c) # [1, [2, 3]]
print(d) # [10, [2, 3]]
print(id(c[1]))
print(id(d[1]))  # 둘은 같은 주소
d[1][0] = 30
print(c) # [1, [30, 3]]
print(d) # [10, [30, 3]]
```